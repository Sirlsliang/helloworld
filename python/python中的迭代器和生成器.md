## Python中的迭代器和生成器


#### 迭代器:
>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问结束。迭
>代器** 只往前不会后退**。

**迭代器的优点**
对于原生支持随机访问的数据结构(如tuple、list),迭代器和for循环的索引访问相比并无优势。但对于无法随机
访问的数据结构(如set)而言,迭代器是唯一的访问元素的方式。
迭代器的另一个优点就是它不要求你事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代至某个元素时才计
算该元素，而在这之前或者之后，元素可以不存在或者被销毁。特别适合用于遍历一些巨大的或是无限的集合，比
如几个G的文件，或是斐波那契数列等。
只要实现了\_\_iter\_\_()方法的对象，就可以使用迭代器。

**迭代器对象的获取与使用**
利用内建的工厂函数iter(iterable)可以获取迭代器对象,直接调用迭代器对象的next()方法可以访问下一个元素
    
    lst = range(2)
    #获取迭代器
    lt  = iter(lst)
    #访问下一个元素
    lt.next()

迭代器中没有检查是否访问到最后一个元素的函数，当访问到最后一个元素继续调用next()方法时会抛出
StopIteration异常。

    it = iter(lst)
    try:
      while True:
        val = it.next()
        print val
    except  StopIteration:
      pass
python中关键字for是迭代器的语法糖。for循环中python自动调用工厂函数iter()获取迭代器，自动调用
next()获取元素,还完成了检查StopIteration异常的工作。
常见的几个内建数据结构tuple、list、set、dict都支持迭代器，字符串也可以使用迭代器。
自己实现迭代器，需要在类的\_\_iter\_\_方法中返回一个对象，这个对象拥有next()方法，这个方法会在恰当的
时候抛出StopIteration异常。

####生成器
>生成器就是一种迭代器。生成器拥有next方法并且行为与迭代器完全相同，这也就意味着生成器也可以用于
>python的for循环中。另外，对于生成器的特殊语法支持使得编写一个生成器比自定义一个常规的迭代器要简单的
>多，所以生成器也是常用的特性之一。

**获取一个生成器**
定义一个函数，在函数体内使用关键字yield,即可使得函数变为一个生成器函数。
eg：

    def get_0_1_2():
      yield 0
      yield 1
      yield 2
生成器函数的特性如下：
  1. 调用生成器函数将返回一个生成器

          generator = get_0_1_2()
          generator
          <generator object get_0_1_2 at 0x******>
  2. 第一次调用生成器的next()方法时，生成器才开始执行生成器函数(不是构建生成器时),知道遇到yield时暂
     停执行(挂起),并且yield 的参数将作为此次next方法的返回值。

  3. 之后每次调用生成器的next方法，生成器将从上次暂停执行的位置恢复执行生成器函数，知道再次遇到yield
     时暂停，并且同样的，yield的参数将作为next方法的返回值。

  4. 当调用next方法时生成器函数结束(遇到空的return 语句或是到达函数的末尾),则这次next方法的调用将抛
     出StopIteration异常。

  5. 生成器函数每次暂停执行时，函数体内的所有变量都将被封存在生成器当中，并且类似于闭包，即使是同一
     个生成器函数返回的生成器，封存的变量也是相互独立的。
  
          def fibonacci():
            a = b = 1
            yield a
            yield b
            while True:
              a,b = b, a+b
              yield b
          for num in fibonacc():
            if num > 100 : break
            print num
          # 生成器是挂起的，所以 while True并不会无限循环下去。

